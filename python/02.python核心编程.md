# 核心编程

## 知识扩展

### 关于import导入模块

使用import导入模块的具体路径，查看sys.path

从上到下依次是import导包的路径

```python
In [1]: import sys

In [2]: sys.path
Out[2]: 
['',
 '/usr/bin',
 '/usr/lib/python35.zip',
 '/usr/lib/python3.5',
 '/usr/lib/python3.5/plat-x86_64-linux-gnu',
 '/usr/lib/python3.5/lib-dynload',
 '/usr/local/lib/python3.5/dist-packages',
 '/usr/lib/python3/dist-packages',
 '/usr/lib/python3/dist-packages/IPython/extensions',
 '/home/python/.ipython']
```

如果导入的包不在sys.path中，那么可以在代码中给path添加，如sys.path.append("/home")

```python
sys.path.append("/home/xxx/xxx")
sys.path.insert(0,"/home/xxx/xxx") #这样可以优先处理导入模块
```

#### 重新导入模块

是指当一个py文件使用时，已经使用了，然后该文件被修改了，如何在下面的执行中记载最新的修改的py文件

先定义一个自定义模块test.py

```python
def myTest():
    print("--- my test ---")
```

进行导入操作

```python
import test
from imp import *
test.myTest() # 此时修改test.py文件，那么继续执行test.myTest方法依然是旧的
# 使用重载方式
reload(test)
test.myTest()# 此时执行之后是最新的修改
```

#### 避免循环导入模块

什么是循环导入？

2个py模块互相导入，各自需要对方模块中的方法

如a.py

 ```python
from b import b_func

def a_func():
        print("------ a function ------")
        b_func()

a_func()
 ```

如b.py

```python
from a import a_func

def b_func():
    print("---- b function ----")
   
def c_func():
    a_func()
   
c_func()
```

此时执行a.py 或者b.py 会报错

如何避免循环导入？

1. 程序设计上分层，降低耦合
2. 导入语句放在后面需要导入时再导入，例如放在函数体内导入

### == 与 is

```python
a = [11,22,33]
b = [11,22,33]

a == b # True 判断值是否相等
a is b # False 判断引用是否相等
# 从a 和b 的id可以看出地址是不相同的
id(a)
id(b)

#注意 python和java一样也有int类型的常量池 在[-5, 257)之间的数值
c1 = 100
c2 = 100 
c1 == c2 # True
c1 is c2 # False

c3 = 1000
c4 = 1000
c3 == c4 # True
c3 is c4 # False
```

### 深拷贝与浅拷贝

```python
a = [1,2,3]
b = a # 浅拷贝 只是复制了引用
id(a) 
id(b)
# 两者id相同
```

深拷贝，重新开辟一块内存区域，将内容复制，内容相同，引用地址不同

需要引入copy模块

#### deepcopy方法

```python
import copy
a = [1,2,3]
b = copy.deepcopy(a) # 如果a中包含引用，那么会递归深拷贝
a == b # True
a is b # False
```

对于元组

```python
a = [1,2,3]
b = [4,5,6]
c = (a,b)
e = copy.deepcopy(c)
a.append(4)
print(c[0]) # [1,2,3,4]
print(e[0]) # [1,2,3] 说明深度拷贝对于元组来说也是生效的
```

#### copy方法

对于数组而言

```python
a = [1,2,3]
b = [4,5,6]
c = [a,b]
e = copy.copy(c)
a.append(4)
print(c[0])
print(e[0]) # e 和 c 的内容相同 但是id(c) 和 id(e) 不相同，说明不是递归的深度拷贝，只深度拷贝一层
id(c) == id(e) # False
```

对于元组而言

```python
a = [1,2,3]
b = [4,5,6]
c = (a,b)
e = copy.copy(c)
a.append(4)
print(c[0])
print(e[0]) # e 和 c 的内容相同 
id(c) == id(e) # True 这里是元组与数组的copy方法时的区别 由于元组是不可变类型，那么copy的时候会判断如果是可变类型，那么就是浅拷贝
```

### 进制转换

```python
bin(10) # 十进制转二进制
Out[14]: '0b1010'
int("1001",2) # 二进制转十进制

hex(10) # 十进制转16进制
‘0xa’
int('ff',16) # 16 进制转 10进制

bin(0xa) # 16 进制转 2进制

oct(9) # 10进制 转 8 进制

hex(0b1001) # 2进制 转 16进制
```

### 位运算

```python
& 按位与
| 按位或
^ 按位异或
~ 按位取反
<< 按位左移
>> 按位右移

用途: 直接操作二进制,省内存,效率高
```

### 私有化

- xx: 公有变量

- _x: 单前置下划线,私有化属性或方法，from somemodule import *禁止导入,类对象和子类可以访问

- __xx：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)

- __xx__:双前后下划线,用户名字空间的魔法对象或属性。例如:`__init__`, __ 不要自己发明这样的名字

- xx_:单后置下划线,用于避免与Python关键词的冲突

- 通过name mangling（名字重整(目的就是以防子类意外重写基类的方法或者属性)如：_Class__object）机制就可以访问private了。 

```python
  如果定义为__xx
  系统会改名称为_Class__xx 因此访问不到 如 t._Test__num 可以访问到
  使用dir查看对象所有名字重整的对象
  如:
  In [16]: dir([1,2])
  Out[16]: 
  ['__add__',
   '__class__',
   '__contains__',
   '__delattr__',
   '__delitem__',
   '__dir__',
   '__doc__',
   '__eq__',
   '__format__',
   '__ge__',
   '__getattribute__',
   '__getitem__',
   '__gt__',
   '__hash__',
   '__iadd__',
   '__imul__',
   '__init__',
   '__iter__',
   '__le__',
   '__len__',
   '__lt__',
   '__mul__',
   '__ne__',
   '__new__',
   '__reduce__',
   '__reduce_ex__',
   '__repr__',
   '__reversed__',
   '__rmul__',
   '__setattr__',
   '__setitem__',
   '__sizeof__',
   '__str__',
   '__subclasshook__',
   'append',
   'clear',
   'copy',
   'count',
   'extend',
   'index',
   'insert',
   'pop',
   'remove',
   'reverse',
   'sort']
```

### 类的属性property

####   私有属性添加getter和setter方法

```python
class Money(object):
    def __init__(self):
        self.__money = 0

    def getMoney(self):
        return self.__money

    def setMoney(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
```

#### 使用property升级getter和setter方法

```python
class Money(object):
    def __init__(self):
        self.__money = 0

    def getMoney(self):
        return self.__money

    def setMoney(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
    money = property(getMoney, setMoney)
   
In [2]: a = Money()
In [3]: a.money
Out[3]: 0
In [4]: a.money = 100
In [5]: a.money
Out[5]: 100
In [6]: a.getMoney()
Out[6]: 100
```

#### 使用@property取代getter和setter方法

- `@property`成为属性函数，可以对属性赋值时做必要的检查，并保证代码的清晰短小，主要有2个作用
  - 将方法转换为只读
  - 重新实现一个属性的设置和读取方法,可做边界判定

```python
class Money(object):
    def __init__(self):
        self.__money = 0

    @property
    def money(self):
        return self.__money

    @money.setter
    def money(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
            
In [3]: a = Money()
In [4]: a.money
Out[4]: 0
In [5]: a.money = 100
In [6]: a.money
Out[6]: 100
```

### 生成器

什么是生成器？

用于生成列表，与列表推导式功能相似，不同在于，如：

a = [x*2 for x in range(10000000)] 此时生成的列表过大，占用内存过多

而使用生成器生成列表则是在使用到这个元素时依次生成，而非一次性生成，解决了性能问题

如何使用？

#### 简单使用生成器

```python
b = (x*2 for x in range(10))
#此时b是一个生成器对象
# 生成一个值，依次生成，使用next(b) 获取
next(b)
# 如果到生成器的极限值则会抛出异常
StopIteration Traceback (most recent call last)
<ipython-input-25-641a931447e8> in <module>()
----> 1 next(b)
```

生成器保存的是算法，每次调用 next(G) ，就计算出 G 的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出 StopIteration 的异常。当然，这种不断调用 next() 实在是太变态了，正确的方法是使用 for 循环，因为生成器也是可迭代对象。所以，我们创建了一个生成器后，基本上永远不会调用 next() ，而是通过 for 循环来迭代它，并且不需要关心 StopIteration 异常 

#### 创建生成器-yield（产生）

添加了yield修饰符的函数就是一个生成器

示例：斐波拉契数列 1、1、2、3、5、8、13、21  F(n) = F(n-1)+F(n-2) 使用生成器实现

```python
def createNum():
	print("---start---")
	a,b = 0,1
	for i in range(6):
		print("---1---")
		yield b # 将b作为生成器每次生成的结果输出
		print("---2---")
		a,b = b,a+b
		print("---3---")
	print("---end---")   
 
# 注意观察执行顺序
In [8]: from test import *
In [9]: b = createNum()
In [10]: b
Out[10]: <generator object createNum at 0x7f1f3d3db8e0>
In [11]: next(b)
---start---
---1---
Out[11]: 1
In [12]: next(b)
---2---
---3---
---1---
Out[12]: 1
In [13]: next(b)
---2---
---3---
---1---
Out[13]: 2
```

使用生成器

```python
# 可以直接使用for循环进行输出
In [14]: for x in createNum():
   ....:     print(x) 
---start---
---1---
1
---2---
---3---
---1---
1
---2---
---3---
---1---
2
---2---
---3---
---1---
3
---2---
---3---
---1---
5
---2---
---3---
---1---
8
---2---
---3---
---end---
# 也可以使用while循环，不过要对异常进行捕获
f = createNum()
while(true):
    try:
        print(next(f))
    except StopIteration as e:
        break  
```

#### send() 方法

返回值同next调用，不同的是可以传参给生成器，传参的位置是yield 声明的地方

下次执行时，可以将上次的传参带入函数中执行

```python
In [10]: def gen():
   ....:     i = 0
   ....:     while i<5:
   ....:         temp = yield i
   ....:         print(temp)
   ....:         i+=1
```

#### `__next__()`方法

```python
# 如F是一个生成器对象
next(F)
# 执行生成器 同上个方法
F.__next__()
```

生成器的特点：

1. 节约内存
2. 迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的

多任务执行示例：协程处理

```python
In [15]: def test1():
   ....:     while True:
   ....:         print("----1---")
   ....:         yield None
   ....:         

In [16]: def test2():
   ....:     while True:
   ....:         print("----2----")
   ....:         yield None
   ....:         

In [17]: t1 = test1()

In [18]: t2 = test2()

In [19]: while True:
   ....:     t1.__next__()
   ....:     t2.__next__()
    
   # 输出是2个while循环协同执行
```

### 迭代器

适用类型：

​	集合类数据类型 ，list、tuple、dict、set、str

​	generator的子类，包括生成器以及带yield的generator的function

可以直接使用for循环的对象

#### 判断是否可以迭代

使用isinstance()判断一个对象是否是Iterable对象

```python
In [1]: from collections import Iterable
In [2]: isinstance([],Iterable)
Out[2]: True
In [3]: isinstance('abc',Iterable)
Out[3]: True
In [4]: isinstance({},Iterable)
Out[4]: True
In [6]: isinstance((x for x in range(10)),Iterable)
Out[6]: True
```

#### 判断是否是迭代器

可以被next()调用的并不断返回下一个值的对象 为迭代器 Iterator

使用isinstance() 判断一个对象是否是Iterator对象

```python
In [20]: from collections import Iterator
In [21]: isinstance([],Iterator)
Out[21]: False
In [22]: isinstance((x for x in range(10)),Iterator)
Out[22]: True
```

#### iter() 方法：把Iterable对象转换成Iterator对象

生成器都是Iterator对象，但是list dict str 虽然是Iterable 但不是Iterator

```python
In [23]: from collections import Iterator
In [24]: isinstance(iter([]),Iterator)
Out[24]: True
```

总结：

- 凡是可作用于 for 循环的对象都是 Iterable 类型；
- 凡是可作用于 next() 函数的对象都是 Iterator 类型
- 集合数据类型如 list 、 dict 、 str 等是 Iterable 但不是 Iterator ，不过可以通过 iter() 函数获得一个 Iterator 对象

### 闭包

 函数引用：同js一样 函数可以通过引用的方式传参和调用 ，可以将函数看成一个对象

```python
def test1():
    print("--- in test1 func----")

#调用函数
test1()
#引用函数
ret = test1
print(id(ret))
print(id(test1))
#通过引用调用函数
ret()
```

什么是闭包？

- 内部函数使用外部函数的参数
- 外部函数返回值是内部函数的引用

```python
#定义一个函数
def test(number):

    #在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包
    def test_in(number_in):
        print("in test_in 函数, number_in is %d"%number_in)
        return number+number_in
    #其实这里返回的就是闭包的结果
    return test_in

#给test函数赋值，这个20就是给参数number
ret = test(20)
#注意这里的100其实给参数number_in
print(ret(100))
#注意这里的200其实给参数number_in
print(ret(200))
```

 示例：

```python
def line_conf(a, b):
    def line(x):
        return a*x + b
    return line

line1 = line_conf(1, 1)
line2 = line_conf(4, 5)
print(line1(5))
print(line2(5))
```

函数line与变量a,b构成闭包。在创建闭包的时候，我们通过line_conf的参数a,b说明了这两个变量的取值，这样，我们就确定了函数的最终形式(y = x + 1和y = 4x + 5)。我们只需要变换参数a,b，就可以获得不同的直线表达函数。由此，我们可以看到，闭包也具有提高代码可复用性的作用 

如果没有闭包，我们需要每次创建直线函数的时候同时说明a,b,x。这样，我们就需要更多的参数传递，也减少了代码的可移植性 

```
1.闭包似优化了变量，原来需要类对象完成的工作，闭包也可以完成
2.由于闭包引用了外部函数的局部变量，则外部函数的局部变量没有及时释放
```

### 装饰器

python的语法糖

符合开放封闭原则，对扩展开放，对已有功能封闭

装饰器：给原有的方法添加其他功能，类似于java中的代理

```python
def w1(func): # 外部传入的函数引用，供给闭包调用
    def inner(): # 固定写法 inner 的闭包
        # 验证1
        # 验证2
        # 验证3
        if True:
            func()
        else:
            print("没有权限")
    return inner

@w1
def f1():
    print('f1')
@w1
def f2():
    print('f2')
@w1
def f3():
    print('f3')
@w1
def f4():
    print('f4')
    
# 语法糖写法    
# @w1 等价于 f1 = w1(f1)
```

示例：

```python
#定义函数：完成包裹数据
def makeBold(fn):
    def wrapped():
        return "<b>" + fn() + "</b>"
    return wrapped

#定义函数：完成包裹数据
def makeItalic(fn):
    def wrapped():
        return "<i>" + fn() + "</i>"
    return wrapped

@makeBold
def test1():
    return "hello world-1"

@makeItalic
def test2():
    return "hello world-2"

@makeBold
@makeItalic
def test3():
    return "hello world-3"

print(test1())
print(test2())
print(test3())
# 结果
<b>hello world-1</b>
<i>hello world-2</i>
<b><i>hello world-3</i></b>
```

应用场景：

1. 引入日志
2. 函数执行时间统计
3. 执行函数前预备处理
4. 执行函数后清理功能
5. 权限校验等场景
6. 缓存

#### 无参数函数

```python

```

