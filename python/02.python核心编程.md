# 核心编程

## 知识扩展

### 关于import导入模块

使用import导入模块的具体路径，查看sys.path

从上到下依次是import导包的路径

```python
In [1]: import sys

In [2]: sys.path
Out[2]: 
['',
 '/usr/bin',
 '/usr/lib/python35.zip',
 '/usr/lib/python3.5',
 '/usr/lib/python3.5/plat-x86_64-linux-gnu',
 '/usr/lib/python3.5/lib-dynload',
 '/usr/local/lib/python3.5/dist-packages',
 '/usr/lib/python3/dist-packages',
 '/usr/lib/python3/dist-packages/IPython/extensions',
 '/home/python/.ipython']
```

如果导入的包不在sys.path中，那么可以在代码中给path添加，如sys.path.append("/home")

```python
sys.path.append("/home/xxx/xxx")
sys.path.insert(0,"/home/xxx/xxx") #这样可以优先处理导入模块
```

#### 重新导入模块

是指当一个py文件使用时，已经使用了，然后该文件被修改了，如何在下面的执行中记载最新的修改的py文件

先定义一个自定义模块test.py

```python
def myTest():
    print("--- my test ---")
```

进行导入操作

```python
import test
from imp import *
test.myTest() # 此时修改test.py文件，那么继续执行test.myTest方法依然是旧的
# 使用重载方式
reload(test)
test.myTest()# 此时执行之后是最新的修改
```

#### 避免循环导入模块

什么是循环导入？

2个py模块互相导入，各自需要对方模块中的方法

如a.py

 ```python
from b import b_func

def a_func():
        print("------ a function ------")
        b_func()

a_func()
 ```

如b.py

```python
from a import a_func

def b_func():
    print("---- b function ----")
   
def c_func():
    a_func()
   
c_func()
```

此时执行a.py 或者b.py 会报错

如何避免循环导入？

1. 程序设计上分层，降低耦合
2. 导入语句放在后面需要导入时再导入，例如放在函数体内导入

### == 与 is

```python
a = [11,22,33]
b = [11,22,33]

a == b # True 判断值是否相等
a is b # False 判断引用是否相等
# 从a 和b 的id可以看出地址是不相同的
id(a)
id(b)

#注意 python和java一样也有int类型的常量池 在[-5, 257)之间的数值
c1 = 100
c2 = 100 
c1 == c2 # True
c1 is c2 # False

c3 = 1000
c4 = 1000
c3 == c4 # True
c3 is c4 # False
```

### 深拷贝与浅拷贝

```python
a = [1,2,3]
b = a # 浅拷贝 只是复制了引用
id(a) 
id(b)
# 两者id相同
```

深拷贝，重新开辟一块内存区域，将内容复制，内容相同，引用地址不同

需要引入copy模块

#### deepcopy方法

```python
import copy
a = [1,2,3]
b = copy.deepcopy(a) # 如果a中包含引用，那么会递归深拷贝
a == b # True
a is b # False
```

对于元组

```python
a = [1,2,3]
b = [4,5,6]
c = (a,b)
e = copy.deepcopy(c)
a.append(4)
print(c[0]) # [1,2,3,4]
print(e[0]) # [1,2,3] 说明深度拷贝对于元组来说也是生效的
```

#### copy方法

对于数组而言

```python
a = [1,2,3]
b = [4,5,6]
c = [a,b]
e = copy.copy(c)
a.append(4)
print(c[0])
print(e[0]) # e 和 c 的内容相同 但是id(c) 和 id(e) 不相同，说明不是递归的深度拷贝，只深度拷贝一层
id(c) == id(e) # False
```

对于元组而言

```python
a = [1,2,3]
b = [4,5,6]
c = (a,b)
e = copy.copy(c)
a.append(4)
print(c[0])
print(e[0]) # e 和 c 的内容相同 
id(c) == id(e) # True 这里是元组与数组的copy方法时的区别 由于元组是不可变类型，那么copy的时候会判断如果是可变类型，那么就是浅拷贝
```

### 进制转换

```python
bin(10) # 十进制转二进制
Out[14]: '0b1010'
int("1001",2) # 二进制转十进制

hex(10) # 十进制转16进制
‘0xa’
int('ff',16) # 16 进制转 10进制

bin(0xa) # 16 进制转 2进制

oct(9) # 10进制 转 8 进制

hex(0b1001) # 2进制 转 16进制
```

### 位运算

```python
& 按位与
| 按位或
^ 按位异或
~ 按位取反
<< 按位左移
>> 按位右移

用途: 直接操作二进制,省内存,效率高
```

### 私有化

- xx: 公有变量

- _x: 单前置下划线,私有化属性或方法，from somemodule import *禁止导入,类对象和子类可以访问

- __xx：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)

- __xx__:双前后下划线,用户名字空间的魔法对象或属性。例如:`__init__`, __ 不要自己发明这样的名字

- xx_:单后置下划线,用于避免与Python关键词的冲突

- 通过name mangling（名字重整(目的就是以防子类意外重写基类的方法或者属性)如：_Class__object）机制就可以访问private了。 

```python
  如果定义为__xx
  系统会改名称为_Class__xx 因此访问不到 如 t._Test__num 可以访问到
  使用dir查看对象所有名字重整的对象
  如:
  In [16]: dir([1,2])
  Out[16]: 
  ['__add__',
   '__class__',
   '__contains__',
   '__delattr__',
   '__delitem__',
   '__dir__',
   '__doc__',
   '__eq__',
   '__format__',
   '__ge__',
   '__getattribute__',
   '__getitem__',
   '__gt__',
   '__hash__',
   '__iadd__',
   '__imul__',
   '__init__',
   '__iter__',
   '__le__',
   '__len__',
   '__lt__',
   '__mul__',
   '__ne__',
   '__new__',
   '__reduce__',
   '__reduce_ex__',
   '__repr__',
   '__reversed__',
   '__rmul__',
   '__setattr__',
   '__setitem__',
   '__sizeof__',
   '__str__',
   '__subclasshook__',
   'append',
   'clear',
   'copy',
   'count',
   'extend',
   'index',
   'insert',
   'pop',
   'remove',
   'reverse',
   'sort']
```

### 类的属性property

####   私有属性添加getter和setter方法

```python
class Money(object):
    def __init__(self):
        self.__money = 0

    def getMoney(self):
        return self.__money

    def setMoney(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
```

#### 使用property升级getter和setter方法

```python
class Money(object):
    def __init__(self):
        self.__money = 0

    def getMoney(self):
        return self.__money

    def setMoney(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
    money = property(getMoney, setMoney)
   
In [2]: a = Money()
In [3]: a.money
Out[3]: 0
In [4]: a.money = 100
In [5]: a.money
Out[5]: 100
In [6]: a.getMoney()
Out[6]: 100
```

#### 使用@property取代getter和setter方法

- `@property`成为属性函数，可以对属性赋值时做必要的检查，并保证代码的清晰短小，主要有2个作用
  - 将方法转换为只读
  - 重新实现一个属性的设置和读取方法,可做边界判定

```python
class Money(object):
    def __init__(self):
        self.__money = 0

    @property
    def money(self):
        return self.__money

    @money.setter
    def money(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
            
In [3]: a = Money()
In [4]: a.money
Out[4]: 0
In [5]: a.money = 100
In [6]: a.money
Out[6]: 100
```

### 迭代器

