#  核心编程

## 知识扩展

### 关于import导入模块

使用import导入模块的具体路径，查看sys.path

从上到下依次是import导包的路径

```python
In [1]: import sys

In [2]: sys.path
Out[2]: 
['',
 '/usr/bin',
 '/usr/lib/python35.zip',
 '/usr/lib/python3.5',
 '/usr/lib/python3.5/plat-x86_64-linux-gnu',
 '/usr/lib/python3.5/lib-dynload',
 '/usr/local/lib/python3.5/dist-packages',
 '/usr/lib/python3/dist-packages',
 '/usr/lib/python3/dist-packages/IPython/extensions',
 '/home/python/.ipython']
```

如果导入的包不在sys.path中，那么可以在代码中给path添加，如sys.path.append("/home")

```python
sys.path.append("/home/xxx/xxx")
sys.path.insert(0,"/home/xxx/xxx") #这样可以优先处理导入模块
```

#### 重新导入模块

是指当一个py文件使用时，已经使用了，然后该文件被修改了，如何在下面的执行中记载最新的修改的py文件

先定义一个自定义模块test.py

```python
def myTest():
    print("--- my test ---")
```

进行导入操作

```python
import test
from imp import *
test.myTest() # 此时修改test.py文件，那么继续执行test.myTest方法依然是旧的
# 使用重载方式
reload(test)
test.myTest()# 此时执行之后是最新的修改
```

#### 避免循环导入模块

什么是循环导入？

2个py模块互相导入，各自需要对方模块中的方法

如a.py

 ```python
from b import b_func

def a_func():
        print("------ a function ------")
        b_func()

a_func()
 ```

如b.py

```python
from a import a_func

def b_func():
    print("---- b function ----")
   
def c_func():
    a_func()
   
c_func()
```

此时执行a.py 或者b.py 会报错

如何避免循环导入？

1. 程序设计上分层，降低耦合
2. 导入语句放在后面需要导入时再导入，例如放在函数体内导入

### == 与 is

```python
a = [11,22,33]
b = [11,22,33]

a == b # True 判断值是否相等
a is b # False 判断引用是否相等
# 从a 和b 的id可以看出地址是不相同的
id(a)
id(b)

#注意 python和java一样也有int类型的常量池 在[-5, 257)之间的数值
c1 = 100
c2 = 100 
c1 == c2 # True
c1 is c2 # False

c3 = 1000
c4 = 1000
c3 == c4 # True
c3 is c4 # False
```

### 深拷贝与浅拷贝

```python
a = [1,2,3]
b = a # 浅拷贝 只是复制了引用
id(a) 
id(b)
# 两者id相同
```

深拷贝，重新开辟一块内存区域，将内容复制，内容相同，引用地址不同

需要引入copy模块

#### deepcopy方法

```python
import copy
a = [1,2,3]
b = copy.deepcopy(a) # 如果a中包含引用，那么会递归深拷贝
a == b # True
a is b # False
```

对于元组

```python
a = [1,2,3]
b = [4,5,6]
c = (a,b)
e = copy.deepcopy(c)
a.append(4)
print(c[0]) # [1,2,3,4]
print(e[0]) # [1,2,3] 说明深度拷贝对于元组来说也是生效的
```

#### copy方法

对于数组而言

```python
a = [1,2,3]
b = [4,5,6]
c = [a,b]
e = copy.copy(c)
a.append(4)
print(c[0])
print(e[0]) # e 和 c 的内容相同 但是id(c) 和 id(e) 不相同，说明不是递归的深度拷贝，只深度拷贝一层
id(c) == id(e) # False
```

对于元组而言

```python
a = [1,2,3]
b = [4,5,6]
c = (a,b)
e = copy.copy(c)
a.append(4)
print(c[0])
print(e[0]) # e 和 c 的内容相同 
id(c) == id(e) # True 这里是元组与数组的copy方法时的区别 由于元组是不可变类型，那么copy的时候会判断如果是可变类型，那么就是浅拷贝
```

### 进制转换

```python
bin(10) # 十进制转二进制
Out[14]: '0b1010'
int("1001",2) # 二进制转十进制

hex(10) # 十进制转16进制
‘0xa’
int('ff',16) # 16 进制转 10进制

bin(0xa) # 16 进制转 2进制

oct(9) # 10进制 转 8 进制

hex(0b1001) # 2进制 转 16进制
```

### 位运算

```python
& 按位与
| 按位或
^ 按位异或
~ 按位取反
<< 按位左移
>> 按位右移

用途: 直接操作二进制,省内存,效率高
```

### 私有化

- xx: 公有变量

- _x: 单前置下划线,私有化属性或方法，from somemodule import *禁止导入,类对象和子类可以访问

- __xx：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)

- __xx__:双前后下划线,用户名字空间的魔法对象或属性。例如:`__init__`, __ 不要自己发明这样的名字

- xx_:单后置下划线,用于避免与Python关键词的冲突

- 通过name mangling（名字重整(目的就是以防子类意外重写基类的方法或者属性)如：_Class__object）机制就可以访问private了。 

```python
  如果定义为__xx
  系统会改名称为_Class__xx 因此访问不到 如 t._Test__num 可以访问到
  使用dir查看对象所有名字重整的对象
  如:
  In [16]: dir([1,2])
  Out[16]: 
  ['__add__',
   '__class__',
   '__contains__',
   '__delattr__',
   '__delitem__',
   '__dir__',
   '__doc__',
   '__eq__',
   '__format__',
   '__ge__',
   '__getattribute__',
   '__getitem__',
   '__gt__',
   '__hash__',
   '__iadd__',
   '__imul__',
   '__init__',
   '__iter__',
   '__le__',
   '__len__',
   '__lt__',
   '__mul__',
   '__ne__',
   '__new__',
   '__reduce__',
   '__reduce_ex__',
   '__repr__',
   '__reversed__',
   '__rmul__',
   '__setattr__',
   '__setitem__',
   '__sizeof__',
   '__str__',
   '__subclasshook__',
   'append',
   'clear',
   'copy',
   'count',
   'extend',
   'index',
   'insert',
   'pop',
   'remove',
   'reverse',
   'sort']
```

### 类的属性property

####   私有属性添加getter和setter方法

```python
class Money(object):
    def __init__(self):
        self.__money = 0

    def getMoney(self):
        return self.__money

    def setMoney(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
```

#### 使用property升级getter和setter方法

```python
class Money(object):
    def __init__(self):
        self.__money = 0

    def getMoney(self):
        return self.__money

    def setMoney(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
    money = property(getMoney, setMoney)
   
In [2]: a = Money()
In [3]: a.money
Out[3]: 0
In [4]: a.money = 100
In [5]: a.money
Out[5]: 100
In [6]: a.getMoney()
Out[6]: 100
```

#### 使用@property取代getter和setter方法

- `@property`成为属性函数，可以对属性赋值时做必要的检查，并保证代码的清晰短小，主要有2个作用
  - 将方法转换为只读
  - 重新实现一个属性的设置和读取方法,可做边界判定

```python
class Money(object):
    def __init__(self):
        self.__money = 0

    @property
    def money(self):
        return self.__money

    @money.setter
    def money(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
            
In [3]: a = Money()
In [4]: a.money
Out[4]: 0
In [5]: a.money = 100
In [6]: a.money
Out[6]: 100
```

### 生成器

什么是生成器？

用于生成列表，与列表推导式功能相似，不同在于，如：

a = [x*2 for x in range(10000000)] 此时生成的列表过大，占用内存过多

而使用生成器生成列表则是在使用到这个元素时依次生成，而非一次性生成，解决了性能问题

如何使用？

#### 简单使用生成器

```python
b = (x*2 for x in range(10))
#此时b是一个生成器对象
# 生成一个值，依次生成，使用next(b) 获取
next(b)
# 如果到生成器的极限值则会抛出异常
StopIteration Traceback (most recent call last)
<ipython-input-25-641a931447e8> in <module>()
----> 1 next(b)
```

生成器保存的是算法，每次调用 next(G) ，就计算出 G 的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出 StopIteration 的异常。当然，这种不断调用 next() 实在是太变态了，正确的方法是使用 for 循环，因为生成器也是可迭代对象。所以，我们创建了一个生成器后，基本上永远不会调用 next() ，而是通过 for 循环来迭代它，并且不需要关心 StopIteration 异常 

#### 创建生成器-yield（产生）

添加了yield修饰符的函数就是一个生成器

示例：斐波拉契数列 1、1、2、3、5、8、13、21  F(n) = F(n-1)+F(n-2) 使用生成器实现

```python
def createNum():
	print("---start---")
	a,b = 0,1
	for i in range(6):
		print("---1---")
		yield b # 将b作为生成器每次生成的结果输出
		print("---2---")
		a,b = b,a+b
		print("---3---")
	print("---end---")   
 
# 注意观察执行顺序
In [8]: from test import *
In [9]: b = createNum()
In [10]: b
Out[10]: <generator object createNum at 0x7f1f3d3db8e0>
In [11]: next(b)
---start---
---1---
Out[11]: 1
In [12]: next(b)
---2---
---3---
---1---
Out[12]: 1
In [13]: next(b)
---2---
---3---
---1---
Out[13]: 2
```

使用生成器

```python
# 可以直接使用for循环进行输出
In [14]: for x in createNum():
   ....:     print(x) 
---start---
---1---
1
---2---
---3---
---1---
1
---2---
---3---
---1---
2
---2---
---3---
---1---
3
---2---
---3---
---1---
5
---2---
---3---
---1---
8
---2---
---3---
---end---
# 也可以使用while循环，不过要对异常进行捕获
f = createNum()
while(true):
    try:
        print(next(f))
    except StopIteration as e:
        break  
```

#### send() 方法

返回值同next调用，不同的是可以传参给生成器，传参的位置是yield 声明的地方

下次执行时，可以将上次的传参带入函数中执行

```python
In [10]: def gen():
   ....:     i = 0
   ....:     while i<5:
   ....:         temp = yield i
   ....:         print(temp)
   ....:         i+=1
```

#### `__next__()`方法

```python
# 如F是一个生成器对象
next(F)
# 执行生成器 同上个方法
F.__next__()
```

生成器的特点：

1. 节约内存
2. 迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的

多任务执行示例：协程处理

```python
In [15]: def test1():
   ....:     while True:
   ....:         print("----1---")
   ....:         yield None
   ....:         

In [16]: def test2():
   ....:     while True:
   ....:         print("----2----")
   ....:         yield None
   ....:         

In [17]: t1 = test1()

In [18]: t2 = test2()

In [19]: while True:
   ....:     t1.__next__()
   ....:     t2.__next__()
    
   # 输出是2个while循环协同执行
```

### 迭代器

适用类型：

​	集合类数据类型 ，list、tuple、dict、set、str

​	generator的子类，包括生成器以及带yield的generator的function

可以直接使用for循环的对象

#### 判断是否可以迭代

使用isinstance()判断一个对象是否是Iterable对象

```python
In [1]: from collections import Iterable
In [2]: isinstance([],Iterable)
Out[2]: True
In [3]: isinstance('abc',Iterable)
Out[3]: True
In [4]: isinstance({},Iterable)
Out[4]: True
In [6]: isinstance((x for x in range(10)),Iterable)
Out[6]: True
```

#### 判断是否是迭代器

可以被next()调用的并不断返回下一个值的对象 为迭代器 Iterator

使用isinstance() 判断一个对象是否是Iterator对象

```python
In [20]: from collections import Iterator
In [21]: isinstance([],Iterator)
Out[21]: False
In [22]: isinstance((x for x in range(10)),Iterator)
Out[22]: True
```

#### iter() 方法：把Iterable对象转换成Iterator对象

生成器都是Iterator对象，但是list dict str 虽然是Iterable 但不是Iterator

```python
In [23]: from collections import Iterator
In [24]: isinstance(iter([]),Iterator)
Out[24]: True
```

总结：

- 凡是可作用于 for 循环的对象都是 Iterable 类型；
- 凡是可作用于 next() 函数的对象都是 Iterator 类型
- 集合数据类型如 list 、 dict 、 str 等是 Iterable 但不是 Iterator ，不过可以通过 iter() 函数获得一个 Iterator 对象

### 闭包

 函数引用：同js一样 函数可以通过引用的方式传参和调用 ，可以将函数看成一个对象

```python
def test1():
    print("--- in test1 func----")

#调用函数
test1()
#引用函数
ret = test1
print(id(ret))
print(id(test1))
#通过引用调用函数
ret()
```

什么是闭包？

- 内部函数使用外部函数的参数
- 外部函数返回值是内部函数的引用

```python
#定义一个函数
def test(number):

    #在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包
    def test_in(number_in):
        print("in test_in 函数, number_in is %d"%number_in)
        return number+number_in
    #其实这里返回的就是闭包的结果
    return test_in

#给test函数赋值，这个20就是给参数number
ret = test(20)
#注意这里的100其实给参数number_in
print(ret(100))
#注意这里的200其实给参数number_in
print(ret(200))
```

 示例：

```python
def line_conf(a, b):
    def line(x):
        return a*x + b
    return line

line1 = line_conf(1, 1)
line2 = line_conf(4, 5)
print(line1(5))
print(line2(5))
```

函数line与变量a,b构成闭包。在创建闭包的时候，我们通过line_conf的参数a,b说明了这两个变量的取值，这样，我们就确定了函数的最终形式(y = x + 1和y = 4x + 5)。我们只需要变换参数a,b，就可以获得不同的直线表达函数。由此，我们可以看到，闭包也具有提高代码可复用性的作用 

如果没有闭包，我们需要每次创建直线函数的时候同时说明a,b,x。这样，我们就需要更多的参数传递，也减少了代码的可移植性 

```
1.闭包似优化了变量，原来需要类对象完成的工作，闭包也可以完成
2.由于闭包引用了外部函数的局部变量，则外部函数的局部变量没有及时释放
```

### 装饰器

python的语法糖

符合开放封闭原则，对扩展开放，对已有功能封闭

装饰器：给原有的方法添加其他功能，类似于java中的代理

```python
def w1(func): # 外部传入的函数引用，供给闭包调用
    def inner(): # 固定写法 inner 的闭包
        # 验证1
        # 验证2
        # 验证3
        if True:
            func()
        else:
            print("没有权限")
    return inner

@w1
def f1():
    print('f1')
@w1
def f2():
    print('f2')
@w1
def f3():
    print('f3')
@w1
def f4():
    print('f4')
    
# 语法糖写法    
# @w1 等价于 f1 = w1(f1)
```

示例：2个装饰器，注意执行的顺序于书写的顺序一致，层层嵌套，从上往下装饰，从下往上调用

```python
#定义函数：完成包裹数据
def makeBold(fn):
    def wrapped():
        return "<b>" + fn() + "</b>"
    return wrapped

#定义函数：完成包裹数据
def makeItalic(fn):
    def wrapped():
        return "<i>" + fn() + "</i>"
    return wrapped

@makeBold
def test1():
    return "hello world-1"

@makeItalic
def test2():
    return "hello world-2"

@makeBold
@makeItalic
def test3():
    return "hello world-3"

print(test1())
print(test2())
print(test3())
# 结果
<b>hello world-1</b>
<i>hello world-2</i> 
<b><i>hello world-3</i></b>
```

应用场景：

1. 引入日志
2. 函数执行时间统计
3. 执行函数前预备处理
4. 执行函数后清理功能
5. 权限校验等场景
6. 缓存

装饰器执行的时间：

​	只要py代码解释到了@w1这句，那么就会自动执行装饰，等价于执行 f1 = w1(f1)

​	而不是要等到调用的时候才执行



#### 无参数函数装饰

```python
def func(funcName):
    print("---func----")
    def func_in():
        print("----func in----")
        funcName()
        print("----funcName----")

    print("----func 2---")
    return func_in

@func
def test():
    print("---test---")

#test = func(test)
test()
# 结果：
---func----
----func 2---
----func in----
---test---
----funcName----
```

示例：

```python
from time import ctime, sleep

def timefun(func):
    def wrappedfunc():
        print("%s called at %s"%(func.__name__, ctime()))
        func()
    return wrappedfunc

@timefun
def foo():
    print("I am foo")

foo()
sleep(2)
foo()
```



#### 有参数函数装饰

```python
from time import ctime,sleep

def timefun(func):
    def wrappedfunc(a,b):
        print("%s called at %s"%(func.__name__,ctime()))
        print(a,b)
        func(a,b)

    return wrappedfunc

@timefun
def test(a,b):
    print(a+b)

test(2,3)
```



#### 不定长参数函数装饰

```python
from time import ctime, sleep

def timefun(func):
    def wrappedfunc(*args, **kwargs):
        print("%s called at %s"%(func.__name__, ctime()))
        func(*args, **kwargs)
    return wrappedfunc

@timefun
def foo(a, b, c):
    print(a+b+c)

foo(3,5,7)
sleep(2)
foo(2,4,9)
```



#### 含有返回值的函数装饰

```python
from time import ctime,sleep

def timefun(func):
    def wrappedfunc(a,b):
        print("%s called at %s"%(func.__name__,ctime()))
        print(a,b)
        return func(a,b) # 对于有返回值的，这里需要进行返回操作

    return wrappedfunc

@timefun
def test(a,b):
    return (a+b)

print(test(2,3))
```

通用的装饰器是不定长参数和含有返回值装饰结合在一起

#### 装饰器中传参

在原有装饰器的基础上，设置外部变量，使用双层嵌套闭包实现

```python
from time import ctime,sleep

def time_arg(param="type1"):
	def time_func(func):
		def wrapped_func():
			if (param == "type1"):
				print("%s called at %s %s"%(func.__name__,ctime(),param))
			elif (param == "type2"):
				print("type2----")
			elif (param == "type3"):
				print("type3----")
			else:
				print("unknown")
			func()
		return wrapped_func
	return time_func

@time_arg("type3")
def foo1():
    print("foo1----")

@time_arg() # 注意是缺省值需要有一个大括号来表示
def foo2():
    print("foo2---")

foo1()
foo2()
# 本质上 @time_arg 等价于 foo1 = time_arg("type3")(foo1)
```



### 作用域

#### locals

查看局部变量信息

```python
locals()
```

#### globals

查看当前的所有全局变量，在python3和ipython3中的显示内容有所区别

```python
In [2]: globals()
Out[2]: 
{'_iii': '',
 '__spec__': None,
 '_sh': <module 'IPython.core.shadowns' from '/usr/lib/python3/dist-packages/IPython/core/shadowns.py'>,
 'quit': <IPython.core.autocall.ExitAutocall at 0x7ff28309c518>,
 'In': ['', 'globals', 'globals()'],
 '__name__': '__main__',
 '_ih': ['', 'globals', 'globals()'],
 '_i': 'globals',
 '__loader__': None,
 'exit': <IPython.core.autocall.ExitAutocall at 0x7ff28309c518>,
 'Out': {1: <function globals>},
 '__': '',
 '__doc__': 'Automatically created module for IPython interactive environment',
 '_': <function globals>,
 '_1': <function globals>,
 '__builtin__': <module 'builtins' (built-in)>,
 '_oh': {1: <function globals>},
 '_ii': '',
 '_i1': 'globals',
 '_dh': ['/home/python/Desktop/python-study/pro'],
 'get_ipython': <bound method InteractiveShell.get_ipython of <IPython.terminal.interactiveshell.TerminalInteractiveShell object at 0x7ff285563358>>,
 '__package__': None,
 '__builtins__': <module 'builtins' (built-in)>,
 '_i2': 'globals()',
 '___': ''}
```

#### LEGB 规则

Python 使用 LEGB 的顺序来查找一个符号对应的对象 

```python
locals -> enclosing function -> globals -> builtins
```

locals，当前所在命名空间（如函数、模块），函数的参数也属于命名空间内的变量enclosing，外部嵌套函数的命名空间（闭包中常见）

```
def fun1():
  a = 10
  def fun2():
      # a 位于外部嵌套函数的命名空间
      print(a)
```

globals，全局变量，函数定义所在模块的命名空间

```
a = 1
def fun():
  # 需要通过 global 指令来声明全局变量
  global a
  # 修改全局变量，而不是创建一个新的 local 变量
  a = 2
```

builtins，内建模块的命名空间 

```
  Python 在启动的时候会自动为我们载入很多内建的函数、类，
  比如 dict，list，type，print，这些都位于 __builtin__ 模块中，
  可以使用 dir(__builtin__) 来查看。
  这也是为什么我们在没有 import任何模块的情况下，
  就能使用这么多丰富的函数和功能了。

  在Python中，有一个内建模块，该模块中有一些常用函数;在Python启动后，
  且没有执行程序员所写的任何代码前，Python会首先加载该内建函数到内存。
  另外，该内建模块中的功能可以直接使用，不用在其前添加内建模块前缀，
  其原因是对函数、变量、类等标识符的查找是按LEGB法则，其中B即代表内建模块
  比如：内建模块中有一个abs()函数，其功能求绝对值，如abs(-20)将返回20。
```

### 动态添加属性和方法

动态编程语言定义：

`动态编程语言` 是 `高级程序设计语言` 的一个类别，在计算机科学领域已被广泛应用。它是一类 在`运行时可以改变其结构`的语言 ：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。动态语言目前非常具有活力。例如JavaScript便是一个动态语言，除此之外如 PHP 、 Ruby 、 Python 等也都属于动态语言，而 C 、 C++ 等语言则不属于动态语言 

#### 在创建对象后添加属性和方法

```python
import types

#定义了一个类
class Person(object):
    num = 0
    def __init__(self, name = None, age = None):
        self.name = name
        self.age = age
    def eat(self):
        print("eat food")

#定义一个实例方法
def run(self, speed):
    print("%s在移动, 速度是 %d km/h"%(self.name, speed))

#定义一个类方法
@classmethod
def testClass(cls):
    cls.num = 100

#定义一个静态方法
@staticmethod
def testStatic():
    print("---static method----")

#创建一个实例对象
P = Person("老王", 24)
#调用在class中的方法
P.eat()

#给这个对象添加实例方法 
#注意：该方法的作用是将P作为参数传入run方法的self中，并返回一个传入该P对象的方法引用，猜测这里也是闭包实现的
P.run = types.MethodType(run, P)
#调用实例方法
P.run(180)

#给Person类绑定类方法
Person.testClass = testClass
#调用类方法
print(Person.num)
Person.testClass()
print(Person.num)

#给Person类绑定静态方法
Person.testStatic = testStatic
#调用静态方法
Person.testStatic()
```

#### 删除属性和方法

1.del 对象.属性名

2.delattr(对象, "属性名")

通过以上例子可以得出一个结论：相对于动态语言，静态语言具有严谨性！所以，玩动态语言的时候，小心动态的坑！那么怎么避免这种情况呢？ 请使用`__slots__`

#### 限制动态添加属性(slots)

使用`__slots__`限定属性成员对象后，再动态添加属性后会报错

```python
>>> class Person(object):
    __slots__ = ("name", "age")

>>> P = Person()
>>> P.name = "老王"
>>> P.age = 20
>>> P.score = 100
Traceback (most recent call last):
  File "<pyshell#3>", line 1, in <module>
AttributeError: Person instance has no attribute 'score'
>>>
```

注意：`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的

