# 核心编程

## 知识扩展

### 关于import导入模块

使用import导入模块的具体路径，查看sys.path

从上到下依次是import导包的路径

```python
In [1]: import sys

In [2]: sys.path
Out[2]: 
['',
 '/usr/bin',
 '/usr/lib/python35.zip',
 '/usr/lib/python3.5',
 '/usr/lib/python3.5/plat-x86_64-linux-gnu',
 '/usr/lib/python3.5/lib-dynload',
 '/usr/local/lib/python3.5/dist-packages',
 '/usr/lib/python3/dist-packages',
 '/usr/lib/python3/dist-packages/IPython/extensions',
 '/home/python/.ipython']
```

如果导入的包不在sys.path中，那么可以在代码中给path添加，如sys.path.append("/home")

```python
sys.path.append("/home/xxx/xxx")
sys.path.insert(0,"/home/xxx/xxx") #这样可以优先处理导入模块
```

#### 重新导入模块

是指当一个py文件使用时，已经使用了，然后该文件被修改了，如何在下面的执行中记载最新的修改的py文件

先定义一个自定义模块test.py

```python
def myTest():
    print("--- my test ---")
```

进行导入操作

```python
import test
from imp import *
test.myTest() # 此时修改test.py文件，那么继续执行test.myTest方法依然是旧的
# 使用重载方式
reload(test)
test.myTest()# 此时执行之后是最新的修改
```

#### 避免循环导入模块

什么是循环导入？

2个py模块互相导入，各自需要对方模块中的方法

如a.py

 ```python
from b import b_func

def a_func():
        print("------ a function ------")
        b_func()

a_func()
 ```

如b.py

```python
from a import a_func

def b_func():
    print("---- b function ----")
   
def c_func():
    a_func()
   
c_func()
```

此时执行a.py 或者b.py 会报错

如何避免循环导入？

1. 程序设计上分层，降低耦合
2. 导入语句放在后面需要导入时再导入，例如放在函数体内导入

### == 与 is

```python
a = [11,22,33]
b = [11,22,33]

a == b # True 判断值是否相等
a is b # False 判断引用是否相等
# 从a 和b 的id可以看出地址是不相同的
id(a)
id(b)

#注意 python和java一样也有int类型的常量池 在[-5, 257)之间的数值
c1 = 100
c2 = 100 
c1 == c2 # True
c1 is c2 # False

c3 = 1000
c4 = 1000
c3 == c4 # True
c3 is c4 # False
```

### 深拷贝与浅拷贝

```python
a = [1,2,3]
b = a # 浅拷贝 只是复制了引用
id(a) 
id(b)
# 两者id相同
```

深拷贝，重新开辟一块内存区域，将内容复制，内容相同，引用地址不同

需要引入copy模块

```python
import copy
a = [1,2,3]
b = copy.deepcopy(a)
a == b # True
a is b # False
```



